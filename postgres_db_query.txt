

/*

------------------------------------------------------------
-- Syntax Theory
------------------------------------------------------------

-- HAVING выполняется after(после того как) groups and aggregates were 
computed.

-- WHERE выполняется before(перед тем как) groups and aggregates are 
computed (так как "where" controls which rows попадут into(в) aggregate-input). 
Поэтому если какая-то фильтрация не затрагивает "логику агрегации и 
группировки" то более оптимизированно писать "эту" фильтрацию в "where" 
(ежели(чем) в "having"-e), так как тогда строки отфильтруются на более-раннем 
этапе(stage-джe). 

-- Join-statement выполняется Раньше чем Where-statement 
поэтому в Where можно написать условие которое будет применено к 
уже-сформированному join-result-y.

-- Explain query plan:
EXPLAIN SELECT * FROM table_name;
EXPLAIN ANALYZE SELECT * FROM table_name; -- ! with execution !

*/

-- Joins

// view data:
SELECT e.employee_id , e.first_name, e.last_name FROM employees e
// output:
employee_id|first_name|last_name|
-----------+----------+---------+
          1|John      |Doe      |
          2|Jane      |Smith    |
          3|Bob       |Johnson  |
          4|Alice     |Brown    |
          5|Charlie   |Wilson   |

// view data:
SELECT t.id, t.task_description, t.employee_id FROM tasks t
// output:
id|task_description|employee_id|
--+----------------+-----------+
 1|Task 1          |          1|
 2|Task 2          |          2|
 3|Task 3          |          1|
 4|Task 4          |           | -- NULL
 5|Task 5          |          3|


-- Inner Join (=Join)
p.s. строки из двух таблиц "мержатся" по condition-у (несовпадающие строки не выводятся).
// query:
SELECT e.employee_id , e.first_name, e.last_name, t.id 
FROM employees e
INNER JOIN tasks t ON t.employee_id = e.employee_id
// output:
employee_id|first_name|last_name|id|
-----------+----------+---------+--+
          1|John      |Doe      | 1|
          2|Jane      |Smith    | 2|
          1|John      |Doe      | 3|
          3|Bob       |Johnson  | 5|


-- Left Join (=Left Outer Join)
p.s. выводятся все строки из левой таблицы,
к ним мержатся только-"совпадающие" строки из правой таблицы.
// query:
SELECT e.employee_id , e.first_name, e.last_name, t.id 
FROM employees e
LEFT JOIN tasks t ON t.employee_id = e.employee_id
// output:
employee_id|first_name|last_name|id|
-----------+----------+---------+--+
          1|John      |Doe      | 1|
          2|Jane      |Smith    | 2|
          1|John      |Doe      | 3|
          3|Bob       |Johnson  | 5|
          5|Charlie   |Wilson   |  |
          4|Alice     |Brown    |  |


-- Only-Left data, excluding Inner data:
// query:
SELECT e.employee_id , e.first_name, e.last_name, t.id 
FROM employees e
LEFT JOIN tasks t ON t.employee_id = e.employee_id
WHERE t.id IS NULL
// output:
employee_id|first_name|last_name|id|
-----------+----------+---------+--+
          5|Charlie   |Wilson   |  |
          4|Alice     |Brown    |  |


-- Right Join (=Right Outer Join)
p.s. выводятся все строки из правой таблицы,
к ним мержатся только-"совпадающие" строки из левой таблицы.
// query:
SELECT e.employee_id , e.first_name, e.last_name, t.id 
FROM employees e
RIGHT JOIN tasks t ON t.employee_id = e.employee_id
// output:
employee_id|first_name|last_name|id|
-----------+----------+---------+--+
          1|John      |Doe      | 1|
          2|Jane      |Smith    | 2|
          1|John      |Doe      | 3|
           |          |         | 4|
          3|Bob       |Johnson  | 5|


-- Only-Right data, excluding Inner data:
// query:
SELECT e.employee_id , e.first_name, e.last_name, t.id 
FROM employees e
RIGHT JOIN tasks t ON t.employee_id = e.employee_id
WHERE e.employee_id IS NULL
// output:
employee_id|first_name|last_name|id|
-----------+----------+---------+--+
           |          |         | 4|


-- Full Outer Join
p.s. выводятся все строки из двух таблиц ("совпадающие" строки  "мержатся" (по condition-у), несовпадающие строки просто выводятся).
// query:
SELECT e.employee_id , e.first_name, e.last_name, t.id 
FROM employees e
FULL OUTER JOIN tasks t ON t.employee_id = e.employee_id
// output:
employee_id|first_name|last_name|id|
-----------+----------+---------+--+
          1|John      |Doe      | 1|
          2|Jane      |Smith    | 2|
          1|John      |Doe      | 3|
           |          |         | 4|
          3|Bob       |Johnson  | 5|
          5|Charlie   |Wilson   |  |
          4|Alice     |Brown    |  |


-- Full Outer data, excluding Inner data:
// query:
SELECT e.employee_id , e.first_name, e.last_name, t.id 
FROM employees e
FULL OUTER JOIN tasks t ON t.employee_id = e.employee_id
WHERE 
    e.employee_id IS NULL OR 
    t.id IS NULL
// output:
employee_id|first_name|last_name|id|
-----------+----------+---------+--+
           |          |         | 4|
          5|Charlie   |Wilson   |  |
          4|Alice     |Brown    |  |
          

-- "Cross Join" это тоже самое что "From из 2-х таблиц"
p.s. выводятся матрица: N x M.
для каждой row из левой таблицы совпадают все rows из правой таблицы.
// query:
SELECT e.employee_id , e.first_name, e.last_name, t.id 
FROM employees e, tasks t
// query:
SELECT e.employee_id , e.first_name, e.last_name, t.id 
FROM employees e
CROSS JOIN tasks t     
// same result:
employee_id|first_name|last_name|id|
-----------+----------+---------+--+
          1|John      |Doe      | 1|
          2|Jane      |Smith    | 1|
          3|Bob       |Johnson  | 1|
          4|Alice     |Brown    | 1|
          5|Charlie   |Wilson   | 1|
          1|John      |Doe      | 2|
          2|Jane      |Smith    | 2|
          3|Bob       |Johnson  | 2|
          4|Alice     |Brown    | 2|
          5|Charlie   |Wilson   | 2|
          1|John      |Doe      | 3|
          2|Jane      |Smith    | 3|
          3|Bob       |Johnson  | 3|
          4|Alice     |Brown    | 3|
          5|Charlie   |Wilson   | 3|
          1|John      |Doe      | 4|
          2|Jane      |Smith    | 4|
          3|Bob       |Johnson  | 4|
          4|Alice     |Brown    | 4|
          5|Charlie   |Wilson   | 4|
          1|John      |Doe      | 5|
          2|Jane      |Smith    | 5|
          3|Bob       |Johnson  | 5|
          4|Alice     |Brown    | 5|
          5|Charlie   |Wilson   | 5|


-- Indexes









-- SELECT example
SELECT * FROM employees WHERE salary > 70000 ORDER BY salary DESC;

-- JOIN example
SELECT 
    e.first_name,
    e.last_name,
    d.department_name,
    p.project_name,
    ep.role
FROM employees e
JOIN departments d ON e.department_id = d.department_id
JOIN employee_projects ep ON e.employee_id = ep.employee_id
JOIN projects p ON ep.project_id = p.project_id;

-- Update example
UPDATE employees SET manager_id = 1 WHERE employee_id IN (2, 5);

-- Aggregate function example with GROUP BY and HAVING
SELECT 
    d.department_name,
    COUNT(e.employee_id) as employee_count,
    AVG(e.salary) as avg_salary,
    SUM(e.salary) as total_salary
FROM departments d
LEFT JOIN employees e ON d.department_id = e.department_id
WHERE d.department_name <> 'Sales'
GROUP BY d.department_name
HAVING COUNT(e.employee_id) > 0;

-- Subquery example
SELECT 
    first_name,
    last_name,
    salary,
    (SELECT AVG(salary) FROM employees) as company_avg_salary
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

-- Common Table Expression (CTE)
WITH department_stats AS (
    SELECT 
        department_id,
        COUNT(*) as emp_count,
        AVG(salary) as avg_sal
    FROM employees
    GROUP BY department_id
)
SELECT 
    d.department_name,
    ds.emp_count,
    ds.avg_sal
FROM department_stats ds
JOIN departments d ON ds.department_id = d.department_id;

-- Window function
SELECT 
    first_name,
    last_name,
    salary,
    department_id,
    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as salary_rank,
    AVG(salary) OVER (PARTITION BY department_id) as dept_avg_salary
FROM employees;

-- CASE example
SELECT 
    first_name,
    last_name,
    salary,
    CASE 
        WHEN salary < 150000 THEN 'Junior'
        WHEN salary BETWEEN 150000 AND 300000 THEN 'Mid-level'
        ELSE 'Senior'
    END as level
FROM employees;

-- Recursive CTE for organizational hierarchy
WITH RECURSIVE employee_hierarchy AS (
    -- Base case: employees without managers (top level)
    SELECT 
        employee_id,
        first_name,
        last_name,
        manager_id,
        1 as level,
        ARRAY[first_name || ' ' || last_name] as path
    FROM employees 
    WHERE manager_id IS NULL
    
    UNION ALL
    
    -- Recursive case: employees with managers
    SELECT 
        e.employee_id,
        e.first_name,
        e.last_name,
        e.manager_id,
        eh.level + 1,
        eh.path || (e.first_name || ' ' || e.last_name)
    FROM employees e
    JOIN employee_hierarchy eh ON e.manager_id = eh.employee_id
)
SELECT 
    REPEAT('  ', level-1) || first_name || ' ' || last_name as employee,
    level
FROM employee_hierarchy
ORDER BY path;

-- Transaction example
BEGIN;
UPDATE employees SET department_id = 2 WHERE employee_id = 5;
UPDATE departments SET budget = budget - 50000 WHERE department_id = 1;
UPDATE departments SET budget = budget + 50000 WHERE department_id = 2;
COMMIT;




