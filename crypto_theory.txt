







___________________________________________________________________________________________________


-- GRPC
сериализуется в binary format (protobuf) (примерно как compressed archive по какому-то оптимизированному сжатому алгоритму), 
используется более новая версия HTTP (HTTP-2/HTTP-3).

-- RestAPI
сериализуется в текстовый формат (json/xml/etc) (определенная структура текста, примерно как какой-нибудь язык программирования),
используется более старая версия HTTP (HTTP-1).


____________________________________________________________________________________________________

-- OSI

физический (биты), канальный (фреймы/кадры), etc

SSL & TLS: 
They are the same type of thing. 
TLS is the newer, more secure version of SSL. 

tcp: гарантированная доставка, но более медленная
udp: негарантированная доставка, но быстрее чем tcp (используется для видео)


_____________________________________________________________

-- Симметричное шифрование: 

в Симметричном шифровании 

1 ключ

всё шифруется и расшифровывается этим (то есть: одним и тем же) ключом

то есть:
если у нас в сети 4 узла и мы хотим чтобы они обменивались "шифрованными" сообщениями - то нужно на Каждый из этих 4-х узлов "установить" (то есть добавить в файловую систему) этот (один и тот же) ключ шифрования

в чем минус - выбора подхода "симметричное шифрование":
то что непонятно как передать это (один и тот же ключ) нашим узлам
причем: во первых защищенным образом (то есть чтобы во время передачи "человек-посередине" Не перехватил и Не "подслушал"), во вторых быстрым способом (ну то есть Не передавать вручную)

пример:
сгенерирован один симметричный ключ (SK1)
alice шифрует message by SK1
bob расшифровывает message by SK1


___________________________________________________________


в Ассиметричном шифровании 

2 ключа = то есть одна "пара ключей"

один ключ - публичный
другой ключ - приватный (то есть секретный) 

шифруется - одним ключом, 
а расшифровывается - другим ключом

Публичный ключом - зашифровываем данные,
а Приватным ключом - расшифровываем данные

пример:
bob генерирует пару ключей: публичный(PubKey1) и приватный(PrivKey1),
далее bob передает (shared, делится) to Alice его публичный ключ (PubKey1),
(все видят публичный ключ bob-a),
Alice шифрует message by PubKey1,
bob расшифровывает message by PrivKey1




-- How works HTTPS: 
(взаимодействие: userBrowser, server):


пример:
UserBrowser and NetflixServer

// NetflixServer генерирует пару ключей: публичный(PubKey1) и приватный(PrivKey1),
и еще NetflixServer имеет сертификат(Cert1) который подписан by удостоверяющим центром УЦ(CA = Certificate Authority),
NetflixServer отправляет to UserBrowser-у ключ PubKey1 и сертификат Cert1 (точнее только сертификат, так как сертификат содержит поле "Public Key = PubKey1"),
// UserBrowser генерирует SecretKey1(сессионный ключ) и шифрует его by ключом PubKey1 и отправляет to NetflixServer-y,
// NetflixServer расшифровывает SecretKey1 by ключом PrivKey1,
далее этот SecretKey1 будет использоваться как симметричное шифрование для обмена между NetflixServer и UserBrowser в течение сессии (то есть UserBrowser шифрует сообщение by SecretKey1, а NetflixServer расшифровывает сообщение by SecretKey1, и наоборот)

-- Как браузер проверяет что сертификат (of сервера) подлинный (а не подделка):
сертификат (Cert1) содержит поля:
Subject (ex. netflix.com),
Subject Public Key (ex. PubKey1),
IssuerName (то есть УЦ/CA) (ex. Amazon Root CA),
Issuer Signature (т.е. подпись of CA) (ex. 364CF4ZK)

то есть UserBrowser валидирует (проверяет) что сертификат подписан by CA


-- JWT Auth:
// User sends credentials in httpPostRequest (login,password).
// Server generates privateKey,publicKey. Server creates jwtToken by privateKey. Server sends(reply) jwtToken to User(browser).
// User stores jwtToken in HttpOnly cookie. User sends next requests jwtToken in Header "Authorization".
// Server verifies jwtToken(from inputRequest from Header 'Authorization') by publicKey.



_________________________________________________________

-- Как работает цифровая подпись:

// Signer(подписыватель of подписи) генерирует пару ключей: PubKey1, PrivKey1.
// затем Signer шифрует message (т.е. цифровую подпись) by some HashFunc и затем еще шифрует by PrivKey1.
// затем любой может прочитать (расшифровать) message (подпись) by публичным ключом PubKey1.


____________________________________________________________


-- Как работает Web Auth by JWT Token:

Если симметричное шифрование:
то на Server-е (например в golang microservice-e) задается Secret string, затем этот SecretKey используется для шифрования и расшифровывания(валидации) jwt-токена сервером.

Если ассиметричное:
Private Key: is used to create (sign) the JWT.
Public Key: is used only to verify the JWT's signature.


















